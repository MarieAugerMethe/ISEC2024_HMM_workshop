hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <-       # What are our default distributions?
# Setting up the starting values
mu0 <-       # Define your chosen Mean step lengths
sigma0 <- mu0/2 # SD of the step length
knitr::include_graphics("ODBA_pic.png")
setwd("~/Sync/GitHub/CANSSI_OTN_HMM_2023/Afternoon_Tutorial")
knitr::include_graphics("ODBA_pic.png")
# R packages that will be used for this tutorial
library(readr)
library(momentuHMM)
library(ggplot2)
library(dplyr)
library(lubridate)
# Load data
BlacktipB <- read_delim("BlacktipB.txt",
delim = "\t", escape_double = FALSE,
trim_ws = TRUE)
head(BlacktipB)
sum(is.na(BlacktipB))
BlacktipB_aux = BlacktipB %>%
mutate(Time = as.POSIXct(Time,format = "%m/%d/%Y %H:%M"))
BlacktipB_aux %>%
ggplot(aes(Time,ODBA)) +
geom_line() + geom_hline(yintercept = 2,linetype="dashed",color="blue")
# Transform into proper time format and take 1-min avg
BlacktipB_1min = BlacktipB %>% filter(ODBA <= 2) %>%
mutate(Time = as.POSIXct(Time,format = "%m/%d/%Y %H:%M")) %>%
group_by(Time = floor_date(Time, unit = "1 min")) %>%
summarise(ODBA_avg = mean(ODBA),
temp_avg = mean(Temp),
depth_avg = mean(Depth)) %>%
ungroup() %>%
mutate(Time = as.POSIXct(Time,format = "%Y-%m-%d %H:%M:%S")) %>%
as.data.frame()
head(BlacktipB_1min)
BlacktipB_1min %>%
ggplot(aes(Time,ODBA_avg)) +
geom_line()  + geom_hline(yintercept = .05, color = "red") +
geom_hline(yintercept = .09, color = "red") +
geom_hline(yintercept = 0, color = "purple")
hist(BlacktipB_1min$ODBA_avg,
breaks = 80,
main="Histogram of ODBA",
xlab = "ODBA")
BlacktipBData = prepData(BlacktipB_1min,coordNames = NULL)
stateNames = c("low-activity","high-activity") # define names for each state
mu0 = c(.05,.09) # initial values for the mean of each behavioural state
sigma0 = c(.02,.02) # initial values for the standard deviation of each behavioural state
fit1 = fitHMM(BlacktipBData,
nbStates=2,
stateNames = stateNames,
dist=list(ODBA_avg="gamma"),
Par0 = list(ODBA_avg=c(mu0,sigma0)))
fit1
plot(fit1,breaks = 80)
plotPR(fit1)
# identify most likely state using the Viterbi algorithm
BlacktipB_1min$state <- factor(viterbi(fit1))
# proportion of the behaviour states during the observed period
table(BlacktipB_1min$state)/length(BlacktipB_1min$state)
BlacktipB_1min %>% mutate(day = day(Time)) %>%
ggplot(aes(Time,ODBA_avg)) +
#facet_wrap(~day,scales = "free_x") +
geom_line(alpha=.1) +
geom_point(aes(shape=state,color=state)) + ylab("ODBA (1-min average)")
set.seed(147)
fit1_s2 <- fitHMM(BlacktipBData,
nbState = 2,
stateNames = stateNames,
dist=list(ODBA_avg="gamma"),
Par0 = list(ODBA_avg=c(mu0,sigma0)),
retryFits=10)
fit1_s2
# Add tod covariate
BlacktipB_1min$tod = hour(BlacktipB_1min$Time) + minute(BlacktipB_1min$Time)/60
tod <- BlacktipB_1min$tod
# Prep data
BlacktipBData = prepData(BlacktipB_1min,coordNames = NULL, covNames = "tod")
formula = ~ cosinor(tod, period = 24)
# Add tod covariate
BlacktipB_1min$tod = hour(BlacktipB_1min$Time) + minute(BlacktipB_1min$Time)/60
tod <- BlacktipB_1min$tod
# Prep data
BlacktipBData = prepData(BlacktipB_1min,coordNames = NULL, covNames = "tod")
formula = ~ cosinor(tod, period = 24)
Par0_fit4 <- getPar0(model = fit1, formula = formula)
fit4 = fitHMM(BlacktipBData,
nbStates=2,
stateNames = stateNames,
dist=list(ODBA_avg="gamma"),
beta0 = Par0_fit4$beta,
Par0 = Par0_fit4$Par,
formula = formula)
fit4
plotStationary(fit4, plotCI = TRUE)
# Define design matrix for ODBA_avg
DM <- list(ODBA_avg = list(mean = formula, sd = ~1))
# Fit model
## Same parameter values from fit1
Par0_fit5 <- getPar0(model = fit1,
DM = DM)
fit5 <- fitHMM(BlacktipBData,
nbState = 2,
dist=list(ODBA_avg="gamma"),
Par0 = Par0_fit5$Par,
DM = DM)
fit5
plot(fit5, ask = F, plotCI = T)
{par(mfrow=c(3,1))
plotPR(fit1)
plotPR(fit4)
plotPR(fit5)
}
data.frame(AIC(fit1),
AIC(fit4),
AIC(fit5))
mu2 = c(.04,.06) # This gives 4 and 6 as initial values for estimating the mean parameters
sigma2 = c(.02,.02) # This gives 2 and 2 as initial values for estimating the mean parameters
fit1_s3 <- fitHMM(BlacktipBData,
nbState = 2,
stateNames = stateNames,
dist=list(ODBA_avg="gamma"),
Par0 = list(ODBA_avg=c(mu2,sigma2)))
fit1_s3
mu1 = c(.001,1)
sigma1 = c(1,1)
fit1_s2_long <- fitHMM(BlacktipBData,
nbState = 2,
stateNames = stateNames,
dist=list(ODBA_avg="gamma"),
Par0 = list(ODBA_avg=c(mu1,sigma1)))
fit1_s2_long
plotPR(fit1_s2_long)
# identify most likely state using the Viterbi algorithm
BlacktipB_1min$state_wildPar0 <- factor(viterbi(fit1_s2_long))
# proportion of the behaviour states during the observed period
table(BlacktipB_1min$state_wildPar0)/length(BlacktipB_1min$state_wildPar0)
BlacktipB_1min %>% mutate(day = day(Time)) %>%
ggplot(aes(Time,ODBA_avg)) +
geom_line(alpha=.1) +
geom_point(aes(shape=state_wildPar0,color=state_wildPar0))
setwd("~/Sync/GitHub/CANSSI_OTN_HMM_2023/Morning_Tutorial/Activity")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
library(cowplot)
# Chunk 4: load function
source("utility_functions.R")
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
head(tracks_gps)
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
?preData
library(momentuHMM)
?preData
?prepData
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
library(cowplot)
# Chunk 4: load function
source("utility_functions.R")
# Chunk 5: import_tracks
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
# Chunk 6: look
head(tracks_gps)
# Chunk 7: remove_missing_or_duplicate_data
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
# Chunk 8: plot_gps_data
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Chunk 9: calc_dt
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Chunk 10: calc_track_dt
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# Chunk 11: calc_track_dt2
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# Chunk 12: track_resolution_proportion_NA
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Chunk 13: segmentation
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
# Chunk 14: define_projection
data_sf <- data_split %>%
st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
st_set_crs(4326) %>% # define CRS
st_transform(2962) # reproject data to a UTM
# Chunk 15: crawl_10_min_gps
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins", theta = c(7, 0))
plot(crwOut, animals = "T172062-3", ask = FALSE)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# Chunk 16: prep
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# Chunk 17: prep2
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# take a peak at the data
head(data)
# Chunk 18: inits
par(mfrow= c(1, 2))
hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
# Chunk 19
par(mfrow= c(1, 1))
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
par(mfrow= c(1, 2))
hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
par(mfrow= c(1, 1))
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
# Setting up the starting values
mu0 <-  c(100,600)     # Define your chosen Mean step lengths
sigma0 <- mu0/2 # SD of the step length
# Setting up the starting values
mu0 <-  c(100,600)     # Define your chosen Mean step lengths
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1,1)    # Define Turn angle concentration parameters
# combine starting parameters
Par0 <- list(step = c(stepMean0, stepSD0), angle = c(angleCon0))
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = c(kappa0))
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = nbState,
dist = dist,
Par0 = Par0)
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <- list(step="gamma", angle="vm")      # What are our default distributions?
# Setting up the starting values
mu0 <-  c(100,600)     # Define your chosen Mean step lengths
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1,1)    # Define Turn angle concentration parameters
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = c(kappa0))
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = nbState,
dist = dist,
Par0 = Par0)
# Let's look at parameter estimates
mod
# plot state-dependent distributions
plot(mod, ask = FALSE, plotTracks = FALSE)
# Apply the Viterbi algorithm using your fited model object
dec_states <- viterbi(mod)
# Let's look at predicted states of the first 20 time steps
head(dec_states, 20)
# How many locations in each state do we have?
table(dec_states)
# Calculate the probability of being in each state
statep <- stateProbs(mod)
# Let's look at the state probability matrix
head(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
# plot state-dependent distributions
plot(mod, ask = FALSE, plotTracks = FALSE)
# Apply the Viterbi algorithm using your fited model object
dec_states <- viterbi(mod)
# Let's look at predicted states of the first 20 time steps
head(dec_states, 20)
# How many locations in each state do we have?
table(dec_states)
# Calculate the probability of being in each state
statep <- stateProbs(mod)
# Let's look at the state probability matrix
head(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
# Setting up the starting values
mu2 <- c(400, 600) # Mean step length
sigma2 <- mu2/2 # SD of the step length
kappa2 <- c(1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_2 <- list(step = c(mu2, sigma2), angle = kappa2)
# Fit the same 2 state HMM
mod2 <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0_2)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(original = mod$mle$angle, new = mod2$mle$angle)
list(original = mod$mle$gamma, new = mod2$mle$gamma)
# Fit the same 2-state HMM with retryFits
# This is a random pertubation, so setting the seed to get the same results
set.seed(29)
mod_RF <- fitHMM(data,
nbState = 2,
dist=list(step="gamma", angle="vm"),
Par0 = Par0,
retryFits=10)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(original = mod$mle$angle, new = mod2$mle$angle)
list(original = mod$mle$gamma, new = mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(original = mod$mle$angle, new = mod2$mle$angle)
list(original = mod$mle$gamma, new = mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(original = mod$mle$angle, new = mod2$mle$angle)
list(original = mod$mle$gamma, new = mod2$mle$gamma)
# Fit the same 2-state HMM with retryFits
# This is a random pertubation, so setting the seed to get the same results
set.seed(29)
mod_RF <- fitHMM(data,
nbState = 2,
dist=list(step="gamma", angle="vm"),
Par0 = Par0,
retryFits=10)
# Fit the same 2-state HMM with retryFits
# This is a random pertubation, so setting the seed to get the same results
set.seed(29)
mod_RF <- fitHMM(data,
nbState = 2,
dist=list(step="gamma", angle="vm"),
Par0 = Par0,
retryFits=10)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum,
retryFits = mod_RF$mod$minimum)
?fitHMM
plotPR(mod)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu3 <- c(100, 600, 1000) # Choose the mean step length
kappa3 <- c(0.1,1,1) # Turn angle concentration parameter
# combine starting parameters
Par0_3 <- list(step= c(mu3, sigma3), angle = kappa3)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu3 <- c(100, 600, 1000) # Choose the mean step length
sigma3 <- mu3/2 # SD of the step length
kappa3 <- c(0.1,1,1) # Turn angle concentration parameter
# combine starting parameters
Par0_3 <- list(step= c(mu3, sigma3), angle = kappa3)
# Fit the same 3 state HMM
mod_3state <- fitHMM(data,
nbState = 3,
dist = dist,
Par0 = Par0_3)
plot(mod_3state, plotTracks = FALSE, ask = FALSE)
# Plot your model's pseudo-residuals and any other model outputs of interest
plotPR(mod_3state)
plot(mod_3state, plotTracks = FALSE, ask = FALSE)
# set new formula
formula <- ~cosinor(tod, period = 24)
# set tpm formula and extract initial values from simpler model
Par0_4 <- getPar0(model = mod, formula = formula)
Par0_4
# set tpm formula and extract initial values from simpler model
Par0_4 <- getPar0(model = mod, formula = formula)
Par0_4
